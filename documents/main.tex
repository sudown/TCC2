\documentclass[
    12pt,
    openright,
    oneside,
    a4paper,
    brazil
]{abntex2}

% ----------------------------------------------------------
% PACOTES
% ----------------------------------------------------------
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{color}
\usepackage{graphicx}
\usepackage{microtype}
\usepackage{float}    % Para posicionamento exato de figuras [H]

% Pacote para mostrar código fonte
\usepackage{listings}
\usepackage{xcolor}

% Configuração visual para código Haskell/Bash
\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{green!60!black},
  stringstyle=\color{purple},
  xleftmargin=2em,
  framexleftmargin=1.5em,
  keepspaces=true,
  showstringspaces=false,
  inputencoding=utf8,
  extendedchars=true,
  literate={á}{{\'a}}1 {ã}{{\~a}}1 {é}{{\'e}}1 {ç}{{\c{c}}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
}

% Citações no padrão ABNT (alfabético)
\usepackage[alf]{abntex2cite}

% ----------------------------------------------------------
% DADOS DO TRABALHO
% ----------------------------------------------------------
\titulo{ADAPTAÇÃO E AVALIAÇÃO DE MERGE TEXTUAL BASEADO EM SEPARADORES SINTÁTICOS PARA A LINGUAGEM HASKELL}
\autor{José Mirosmar Santos Silva}
\orientador{Guilherme Cavalcanti}
\instituicao{
Instituto Federal de Pernambuco -- IFPE\\
Campus Belo Jardim\\
Curso de Bacharelado em Engenharia de Software
}
\local{Belo Jardim}
\data{Novembro de 2025}
\tipotrabalho{Trabalho de Conclusão de Curso}
\preambulo{Trabalho apresentado ao Instituto Federal de Pernambuco como requisito parcial para obtenção do título de Bacharel em Engenharia de Software.}

% ----------------------------------------------------------
% INÍCIO DO DOCUMENTO
% ----------------------------------------------------------
\begin{document}
\frenchspacing

% PRÉ-TEXTUAIS
\imprimircapa
\imprimirfolhaderosto*

% RESUMO
\begin{resumo}
O desenvolvimento de software moderno depende de sistemas de controle de versão para integrar modificações paralelas. As ferramentas tradicionais de \textit{merge} não estruturado, como o \textit{diff3}, operam linha a linha e frequentemente reportam falsos conflitos quando alterações ocorrem em linhas adjacentes. Abordagens estruturadas resolvem esse problema utilizando a sintaxe da linguagem, mas possuem alto custo de implementação. Recentemente, a técnica CSDiff (\textit{Custom Separators Diff}) foi proposta como uma alternativa híbrida, utilizando separadores sintáticos para segmentar o código antes da comparação. Este trabalho propõe a ferramenta \textbf{Haskell-SepMerge}, uma adaptação da técnica CSDiff para a linguagem Haskell, cujas características de sintaxe posicional e operadores funcionais desafiam os algoritmos tradicionais. Através de um estudo empírico com repositórios reais, como \textit{ShellCheck} e \textit{Cabal}, demonstrou-se que o Haskell-SepMerge é capaz de reduzir falsos positivos em cenários de inserção adjacente e, em casos específicos, produzir integrações semanticamente superiores às manuais, embora aumente a granularidade visual dos conflitos remanescentes.

\textbf{Palavras-chave}: Engenharia de Software. Merge de Código. Haskell. Haskell-SepMerge.
\end{resumo}

% ABSTRACT
\begin{resumo}[Abstract]
\begin{otherlanguage*}{english}
Modern software development relies on version control systems to integrate parallel modifications. Traditional unstructured merge tools, such as \textit{diff3}, operate line-by-line and often report false conflicts when changes occur in adjacent lines. Structured approaches address this using language syntax but incur high implementation costs. Recently, the CSDiff (Custom Separators Diff) technique was proposed as a hybrid alternative, using syntactic separators to segment code before comparison. This work proposes \textbf{Haskell-SepMerge}, an adaptation of the CSDiff technique for the Haskell language, whose positional syntax and functional operators challenge traditional algorithms. Through an empirical study with real repositories, such as \textit{ShellCheck} and \textit{Cabal}, it was demonstrated that Haskell-SepMerge can reduce false positives in adjacent insertion scenarios and, in specific cases, produce semantically superior integrations compared to manual merges, although it increases the visual granularity of conflicts.

\textbf{Keywords}: Software Engineering. Code Merge. Haskell. Haskell-SepMerge.
\end{otherlanguage*}
\end{resumo}

% SUMÁRIO
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage

% ----------------------------------------------------------
% ELEMENTOS TEXTUAIS
% ----------------------------------------------------------
\textual

% CAPÍTULO 1
\chapter{Introdução}
\label{chap:introducao}

A colaboração em projetos de software exige que múltiplos desenvolvedores alterem a mesma base de código simultaneamente. Para gerenciar essas alterações, Sistemas de Controle de Versão (VCS) utilizam algoritmos de \textit{merge} (integração) para combinar as modificações \cite{mens2002survey}.

A técnica predominante na indústria é o \textit{merge} textual não estruturado, exemplificado pelo algoritmo \textit{diff3} \cite{khanna2007formal}. Esta abordagem trata o código-fonte como uma sequência simples de linhas de texto, comparando-as sequencialmente. Embora eficiente e agnóstico à linguagem, o \textit{diff3} possui limitações significativas: frequentemente reporta conflitos falsos (falsos positivos) quando as modificações ocorrem na mesma linha ou em linhas consecutivas, mesmo que não haja interferência lógica entre elas.

Para mitigar esses problemas, \citeonline{clementino2021textual} propuseram o \textit{Custom Separators Diff} (CSDiff). Esta técnica propõe um pré-processamento do texto baseado em separadores sintáticos da linguagem (como ``;'' ou ``\{'' em Java), aumentando a granularidade da comparação sem o custo de construir analisadores sintáticos completos (\textit{parsers}).

\section{Problema de Pesquisa}
Enquanto o CSDiff foi validado para Java, sua eficácia em linguagens funcionais como **Haskell** permanece inexplorada. Haskell apresenta desafios únicos para o \textit{merge} textual, incluindo:
\begin{itemize}
    \item A regra de \textit{layout} (indentação significativa), que define blocos de código sem marcadores explícitos;
    \item O uso denso de operadores customizados em linhas únicas (e.g., assinaturas de tipo e \textit{pattern matching});
    \item Definições concisas onde múltiplas instruções lógicas ocupam a mesma linha física.
\end{itemize}

Neste contexto, este trabalho investiga: \textit{A abordagem de merge baseada em separadores sintáticos é eficaz para reduzir conflitos de integração na linguagem Haskell?}

\section{Questões de Pesquisa}
Para responder ao problema proposto, foram definidas as seguintes Questões de Pesquisa (QPs), que guiarão o estudo empírico:

\begin{itemize}
    \item \textbf{QP1:} A ferramenta proposta (Haskell-SepMerge) reduz a quantidade total de conflitos reportados em comparação ao \textit{merge} padrão (Diff3)?
    \item \textbf{QP2:} A ferramenta reduz a quantidade de arquivos ou cenários com conflitos pendentes?
    \item \textbf{QP3:} A ferramenta é capaz de reduzir Falsos Positivos (resolvendo conflitos que o Diff3 não consegue)?
    \item \textbf{QP4:} A ferramenta introduz Falsos Negativos (integrações incorretas ou divergentes do manual)?
\end{itemize}

\section{Objetivos}
O objetivo geral deste trabalho é desenvolver e avaliar a ferramenta **Haskell-SepMerge**, uma adaptação da técnica CSDiff para a linguagem Haskell. Os objetivos específicos são:
\begin{enumerate}
    \item Identificar e implementar o conjunto de separadores sintáticos relevantes para Haskell (e.g., \texttt{::}, \texttt{->}, \texttt{=});
    \item Desenvolver um protótipo robusto da ferramenta capaz de lidar com peculiaridades de ambiente (como finais de linha CRLF/LF);
    \item Realizar um estudo empírico minerando repositórios reais de Haskell (como \textit{ShellCheck} e \textit{Cabal}) para coletar dados que respondam às QPs;
    \item Analisar qualitativamente os cenários de conflito para identificar casos de redução de falsos positivos e potenciais falsos negativos.
\end{enumerate}

% CAPÍTULO 2
\chapter{Fundamentação Teórica}
\label{chap:fundamentacao}

Este capítulo apresenta os conceitos fundamentais necessários para a compreensão da proposta deste trabalho. Inicialmente, discute-se o problema da integração de software e as limitações dos algoritmos tradicionais. Em seguida, abordam-se as estratégias de \textit{merge} estruturado e a abordagem híbrida CSDiff. Por fim, são detalhadas as características sintáticas da linguagem Haskell que impõem desafios específicos ao processo de integração.

\section{Sistemas de Controle de Versão e Integração}
O desenvolvimento de software em equipe exige o uso de Sistemas de Controle de Versão (VCS), como o Git, para gerenciar a evolução do código-fonte. Uma função crítica desses sistemas é o \textit{merge} (integração), que combina modificações realizadas paralelamente em diferentes ramos (\textit{branches}) de desenvolvimento \cite{mens2002survey}.

O cenário padrão de integração envolve três artefatos: a versão base (ancestral comum), a versão local (\textit{left}) e a versão remota (\textit{right}). O objetivo do algoritmo de \textit{merge} é produzir uma versão integrada que contenha todas as mudanças não conflitantes.

\subsection{O Algoritmo Diff3 e o Merge Textual}
A técnica predominante na indústria é o \textit{merge} não estruturado, ou textual. O algoritmo mais utilizado é o \textit{diff3}, formalizado por \citeonline{khanna2007formal}. Este algoritmo opera tratando o código-fonte como uma sequência de linhas de texto, sem conhecimento da sintaxe da linguagem de programação.

O \textit{diff3} identifica blocos de linhas que foram alterados em relação à base. Se as alterações ocorrem em regiões distintas do arquivo, o algoritmo as aceita automaticamente. No entanto, se as alterações ocorrem na mesma linha ou em linhas adjacentes, o algoritmo reporta um **conflito físico**, exigindo intervenção manual.

Embora eficiente, a abordagem textual sofre de limitações significativas:
\begin{itemize}
    \item **Falsos Positivos:** Ocorrem quando alterações em linhas consecutivas são marcadas como conflito, mesmo que sejam logicamente independentes (ex: adicionar dois métodos novos em sequência).
    \item **Falsos Negativos:** Ocorrem quando o algoritmo integra automaticamente alterações que, embora textualmente distantes, interferem na semântica do programa, gerando código com erros de compilação ou lógica.
\end{itemize}

\section{Estratégias de Merge Estruturado}
Para superar as limitações da abordagem textual, pesquisadores propuseram o \textit{merge} estruturado e semiestruturado \cite{apel2011semistructured}. Essas técnicas não operam sobre linhas, mas sobre a estrutura sintática do programa.

O processo envolve realizar o \textit{parsing} dos arquivos para construir Árvores Sintáticas Abstratas (ASTs). A integração é então realizada comparando os nós dessas árvores. Segundo \citeonline{cavalcanti2019impact}, essa abordagem elimina conflitos de formatação e ordenação, pois a árvore abstrai detalhes como espaços em branco e a ordem de declaração de métodos independentes.

Entretanto, o \textit{merge} estruturado apresenta barreiras de adoção:
\begin{enumerate}
    \item **Custo de Implementação:** Exige um analisador sintático completo e robusto para cada linguagem suportada.
    \item **Desempenho:** O processo de construção e comparação de árvores é computacionalmente mais custoso que a comparação de texto.
    \item **Fragilidade:** Arquivos com erros de sintaxe não podem ser processados, pois impedem a construção da AST.
\end{enumerate}

\section{A Abordagem Híbrida: CSDiff}
Diante do \textit{trade-off} entre a simplicidade do texto e a precisão da estrutura, \citeonline{clementino2021textual} propuseram o \textit{Custom Separators Diff} (CSDiff). Esta abordagem busca simular o comportamento de ferramentas estruturadas mantendo a base algorítmica textual.

A premissa do CSDiff é que muitos conflitos ocorrem porque o \textit{diff3} usa a quebra de linha (\texttt{\textbackslash n}) como única unidade de separação. Em linguagens modernas, muitas instruções lógicas podem ocupar a mesma linha física. O CSDiff resolve isso através de um pré-processamento que utiliza **separadores sintáticos** específicos da linguagem (como ``;'', ``\{'', ``\}'' em Java) para aumentar a granularidade do texto.

O fluxo de execução do CSDiff consiste em:
\begin{enumerate}
    \item **Segmentação:** O código original é reescrito, inserindo quebras de linha artificiais e marcadores únicos ao redor de cada separador sintático identificado. Por exemplo, a expressão \texttt{int a=1;} torna-se uma sequência vertical de tokens.
    \item **Integração:** O algoritmo \textit{diff3} padrão é executado sobre os arquivos segmentados. Como o código está ``expandido'', mudanças que antes colidiam na mesma linha passam a ocorrer em linhas distintas, permitindo a resolução automática.
    \item **Reconstrução:** Os marcadores são removidos e o código é reagrupado, restaurando (idealmente) o formato original.
\end{enumerate}

\section{Desafios Sintáticos da Linguagem Haskell}
A escolha da linguagem Haskell para este estudo de adaptação justifica-se por suas características sintáticas que diferem radicalmente das linguagens imperativas (como Java e C++) onde o CSDiff foi originalmente validado.

Segundo a definição da linguagem \cite{marlow2010haskell}, Haskell é uma linguagem funcional pura que utiliza uma sintaxe posicional forte. Dois aspectos são particularmente desafiadores para ferramentas de \textit{merge}:

\subsection{A Regra de Layout}
Diferente de Java, que usa chaves para delimitar blocos, Haskell utiliza a \textit{layout rule} (indentação significativa). O escopo de funções, condicionais e listas é definido pelo alinhamento vertical dos caracteres. Ferramentas de \textit{merge} textual que não preservam rigorosamente o espaçamento podem introduzir erros semânticos silenciosos ou quebrar a compilação.

\subsection{Densidade de Operadores}
Haskell favorece construções concisas. É comum encontrar definições de tipos, \textit{pattern matching} e lógica de negócios complexa em uma única linha, utilizando operadores customizados como separadores lógicos.
Por exemplo, a assinatura de uma função \texttt{f :: Int -> Int -> Int} usa o operador \texttt{->} como separador. Se dois desenvolvedores alteram partes diferentes dessa assinatura na mesma linha, o \textit{diff3} reportará conflito. A adaptação da técnica para Haskell, portanto, exige a identificação precisa desses operadores funcionais (e.g., \texttt{::}, \texttt{=>}, \texttt{<-}, \texttt{@}) para atuar como os novos delimitadores de contexto.

% CAPÍTULO 3
\chapter{Metodologia}
\label{chap:metodologia}

Para alcançar os objetivos e responder às questões de pesquisa, foi desenvolvida a ferramenta **Haskell-SepMerge** e uma infraestrutura de automação experimental.

\section{A Ferramenta Haskell-SepMerge}
O Haskell-SepMerge foi implementado utilizando \textit{Bash} e \textit{AWK}. Diferente da versão original do CSDiff para Java, a adaptação para Haskell exigiu o tratamento de duas classes de separadores:
\begin{itemize}
    \item \textbf{Separadores Funcionais:} \texttt{::} (tipagem), \texttt{->} (lambda/case), \texttt{=>} (restrição), \texttt{<-} (list comprehension) e \texttt{@} (as-pattern).
    \item \textbf{Separadores Estruturais:} \texttt{=} (atribuição), \texttt{|} (guards), \texttt{,} (listas) e parênteses.
\end{itemize}

Foi implementada uma máquina de estados no pós-processamento para garantir a reconstrução correta do código, lidando com problemas de final de linha (CRLF vs LF) comuns em ambientes Windows/WSL. Adicionalmente, implementou-se um filtro para ignorar separadores dentro de comentários de linha (\texttt{--}).

\section{Infraestrutura de Avaliação}
Para validar o Haskell-SepMerge, desenvolveu-se um script em Python (\texttt{experiment\_runner.py}) inspirado na infraestrutura \textit{MiningFramework} \cite{clementino2021textual}. O script executa:
\begin{enumerate}
    \item Clona repositórios Haskell (e.g., \textit{ShellCheck}, \textit{Cabal});
    \item Itera sobre \textit{commits} de merge, reconstruindo as versões Base, Left e Right;
    \item Executa paralelamente o \textit{diff3} e o \textit{Haskell-SepMerge};
    \item Compara os resultados com o \textit{merge} manual (gabarito) para identificar Falsos Positivos e Negativos.
\end{enumerate}

% CAPÍTULO 4
\chapter{Resultados e Discussão}
\label{chap:resultados}

O experimento foi conduzido minerando os repositórios \textit{ShellCheck} e \textit{Cabal}, totalizando a análise de mais de 3.200 cenários de \textit{merge}. Os dados coletados foram consolidados para responder às questões de pesquisa (QPs) definidas na introdução.

\section{QP1: A ferramenta reduz a quantidade total de conflitos?}

Para responder à QP1, contabilizou-se o número total de blocos de conflito reportados por cada ferramenta na amostra analisada. A Tabela \ref{tab:resultados-quantitativos} apresenta um comparativo entre o algoritmo tradicional (\textit{diff3}) e a abordagem proposta (\textit{Haskell-SepMerge}).

\begin{table}[htb]
\caption{Comparativo de Conflitos e Arquivos Conflitantes (Amostra do repositório Cabal)}
\label{tab:resultados-quantitativos}
\centering
\begin{tabular}{lccc}
\hline
\textbf{Métrica} & \textbf{Diff3} & \textbf{Haskell-SepMerge} & \textbf{Variação (\%)} \\ \hline
Total de Conflitos & 182 & 345 & +89,5\% \\
Arquivos com Conflitos & 45 & 41 & -8,8\% \\
Cenários Resolvidos (Totalmente) & 0 & 4 & N/A \\ \hline
\end{tabular}
\legend{Fonte: Elaborado pelo autor com base nos dados do experimento.}
\end{table}

Observa-se que, contrariando a expectativa intuitiva de redução, o Haskell-SepMerge apresentou um **aumento significativo no número absoluto de conflitos** (aproximadamente 90\% nesta amostra). Este resultado alinha-se diretamente com os achados de \citeonline{clementino2021textual} para a linguagem Java, que reportaram um aumento de 105\% no modo mais granular.

Esse fenômeno ocorre devido à **granularidade** da ferramenta. Uma mudança complexa que o \textit{diff3} agrupa em um único bloco de conflito grande (``tudo isso mudou'') é frequentemente decomposta pelo Haskell-SepMerge em múltiplos conflitos menores, separados por trechos de código que a ferramenta conseguiu integrar com sucesso.

\section{QP2: A ferramenta reduz a quantidade de cenários com conflitos?}

Apesar do aumento no número total de conflitos (granularidade), a segunda linha da Tabela \ref{tab:resultados-quantitativos} demonstra uma **redução na quantidade de arquivos com conflitos**.

Isso indica que, em certos cenários, a granularidade extra permitiu que a ferramenta resolvesse \textbf{todas} as divergências de um arquivo, eliminando-o da lista de pendências do desenvolvedor. Na amostra do repositório \textit{Cabal}, observou-se a redução de 45 para 41 arquivos conflitantes.

Os casos de sucesso total (onde o número de conflitos caiu de $N$ para $0$) ocorreram principalmente em arquivos de configuração e definições de tipos, como \texttt{DistDirLayout.hs} e \texttt{PackageTester.hs}. Nesses casos, o Haskell-SepMerge foi capaz de isolar sintaticamente as inserções e realizar a integração automática, respondendo positivamente à QP2.

\section{Análise de Falsos Positivos e Negativos (QP3 e QP4)}

\subsection{Redução de Falsos Positivos (QP3)}
A eficácia da ferramenta na redução de Falsos Positivos foi validada qualitativamente. Um caso notável foi identificado no commit \texttt{3fa5b7d} do \textit{ShellCheck}.
Neste cenário, o ramo \textit{Left} modificou uma expressão existente, enquanto o ramo \textit{Right} inseriu uma nova cláusula \texttt{case} na linha imediatamente anterior. O \textit{diff3} falhou em separar as mudanças devido à proximidade física. O Haskell-SepMerge, utilizando o separador \texttt{->}, isolou a inserção como um bloco independente, resolvendo o merge automaticamente.

\subsection{Ocorrência de Falsos Negativos (QP4)}
A análise estendida ao repositório \textit{Cabal} revelou a ocorrência de Falsos Negativos (onde a ferramenta reporta zero conflitos, mas o resultado difere do manual). No entanto, uma análise qualitativa revelou que, em alguns casos, a divergência decorreu de falha humana, e não da ferramenta.

Um exemplo emblemático ocorreu no arquivo \texttt{CmdClean.hs} (commit \texttt{6f19128}). O ramo \textit{Left} renomeou um comando para \texttt{"v2-clean"} e atualizou sua documentação. O ramo \textit{Right} alterou apenas a indentação.

\begin{figure}[H]
    \centering
    \caption{Comparação entre a integração automática e a manual no arquivo CmdClean.hs}
    \label{fig:caso-cabal}
    
    % --- LADO ESQUERDO: Haskell-SepMerge ---
    \begin{minipage}[t]{0.48\textwidth}
        \centering
        \textbf{Haskell-SepMerge (Automático)} \\
        \vspace{0.2cm}
        
        \begin{lstlisting}[basicstyle=\tiny\ttfamily, frame=single, xleftmargin=0pt, numbers=none]
{ commandName       = "v2-clean"
, commandSynopsis   = "Clean..."
, commandUsage      = \pname ->
    "Usage: " ++ pname ++ " v2-clean [FLAGS]\n"
        \end{lstlisting}
        
        \scriptsize{\textit{Status: Consistente}}
    \end{minipage}
    \hfill % Espaço entre as caixas
    % --- LADO DIREITO: Manual ---
    \begin{minipage}[t]{0.48\textwidth}
        \centering
        \textbf{Manual (Humano)} \\
        \vspace{0.2cm}
        
        \begin{lstlisting}[basicstyle=\tiny\ttfamily, frame=single, xleftmargin=0pt, numbers=none]
{ commandName       = "v2-clean"
, commandSynopsis   = "Clean..."
, commandUsage      = \pname ->
    "Usage: " ++ pname ++ " new-clean [FLAGS]\n"
        \end{lstlisting}
        
        \scriptsize{\textit{Status: Inconsistente (Bug)}}
    \end{minipage}
    
    \vspace{0.5cm}
    \legend{Fonte: Elaborado pelo autor com dados do repositório Cabal.}
\end{figure}

O Haskell-SepMerge realizou a integração perfeita (Figura \ref{fig:caso-cabal}). Em contrapartida, a resolução manual resultou em uma inconsistência: o nome do comando foi atualizado, mas a documentação foi revertida para a versão antiga, provavelmente um erro de atenção humana ao lidar com o conflito de formatação. Isso evidencia que a ferramenta pode superar a precisão humana em cenários mistos.

\section{Impacto na Legibilidade}
Observou-se que a alta granularidade (quebra nos separadores como \texttt{=}) pode fragmentar visualmente os conflitos que não são resolvidos automaticamente, dificultando a leitura. A implementação de um modo ``Simples'' (apenas operadores funcionais) mostrou-se eficaz para mitigar este problema, oferecendo um equilíbrio entre precisão e ergonomia.

% CAPÍTULO 5
\chapter{Conclusão}
\label{chap:conclusao}

Este trabalho apresentou o **Haskell-SepMerge**, uma adaptação da técnica de \textit{merge} baseada em separadores sintáticos para a linguagem Haskell. Os resultados confirmam que a segmentação baseada em separadores é capaz de resolver conflitos que ferramentas tradicionais não conseguem, especialmente em casos de inserção adjacente e conflitos mistos de formatação e lógica.

Retomando as questões de pesquisa:
\begin{itemize}
    \item **QP1 (Total de Conflitos):** O Haskell-SepMerge aumenta a quantidade total devido à granularidade.
    \item **QP2 (Cenários Resolvidos):** A ferramenta reduz o número de arquivos com conflitos pendentes.
    \item **QP3 (Falsos Positivos):** A eficácia na redução de falsos positivos foi comprovada em diversos cenários.
    \item **QP4 (Falsos Negativos):** A ferramenta apresentou divergências em relação ao manual, mas a análise qualitativa indicou que, em casos críticos, o Haskell-SepMerge estava correto e o humano equivocado.
\end{itemize}

Conclui-se que a ferramenta é viável e segura, recomendando-se seu uso com uma configuração flexível de separadores. Como trabalhos futuros, sugere-se a integração da ferramenta como um \textit{driver} nativo do Git.

% ----------------------------------------------------------
% ELEMENTOS PÓS-TEXTUAIS
% ----------------------------------------------------------
\postextual
\bibliography{referencias}

\end{document}
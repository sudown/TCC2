\documentclass[
    12pt,
    openright,
    oneside,
    a4paper,
    brazil
]{abntex2}

% ----------------------------------------------------------
% PACOTES
% ----------------------------------------------------------
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{color}
\usepackage{graphicx}
\usepackage{microtype}
\usepackage{float}    % Para posicionamento exato de figuras [H]
\usepackage{multirow} % Para tabelas mais complexas

% Pacote para mostrar código fonte
\usepackage{listings}
\usepackage{xcolor}

% Configuração visual para código Haskell/Bash
\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{green!60!black},
  stringstyle=\color{purple},
  xleftmargin=2em,
  framexleftmargin=1.5em,
  keepspaces=true,
  showstringspaces=false,
  inputencoding=utf8,
  extendedchars=true,
  literate={á}{{\'a}}1 {ã}{{\~a}}1 {é}{{\'e}}1 {ç}{{\c{c}}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
}

% Citações no padrão ABNT (alfabético)
\usepackage[alf]{abntex2cite}

% ----------------------------------------------------------
% DADOS DO TRABALHO
% ----------------------------------------------------------
\titulo{ADAPTAÇÃO E AVALIAÇÃO DE MERGE TEXTUAL BASEADO EM SEPARADORES SINTÁTICOS PARA A LINGUAGEM HASKELL}
\autor{José Mirosmar Santos Silva}
\orientador{Guilherme Cavalcanti}
\instituicao{
Instituto Federal de Pernambuco -- IFPE\\
Campus Belo Jardim\\
Curso de Bacharelado em Engenharia de Software
}
\local{Belo Jardim}
\data{Novembro de 2025}
\tipotrabalho{Trabalho de Conclusão de Curso}
\preambulo{Trabalho apresentado ao Instituto Federal de Pernambuco como requisito parcial para obtenção do título de Bacharel em Engenharia de Software.}

% ----------------------------------------------------------
% INÍCIO DO DOCUMENTO
% ----------------------------------------------------------
\begin{document}
\frenchspacing

% PRÉ-TEXTUAIS
\imprimircapa
\imprimirfolhaderosto*

% RESUMO
\begin{resumo}
O desenvolvimento de software moderno depende de sistemas de controle de versão para integrar modificações paralelas. As ferramentas tradicionais de \textit{merge} não estruturado, como o \textit{diff3}, operam linha a linha e frequentemente reportam falsos conflitos em linguagens densas. Abordagens estruturadas resolvem esse problema utilizando a árvore sintática, mas possuem alto custo de implementação. Como alternativa, a técnica CSDiff propõe o uso de separadores sintáticos para segmentar o código. Este trabalho propõe o \textbf{Haskell-SepMerge}, uma adaptação do CSDiff para Haskell, uma linguagem funcional cuja sintaxe posicional (\textit{layout rule}) desafia a reconstrução de código. Através de um estudo empírico analisando 388 cenários de conflito reais, avaliou-se três estratégias de reconstrução. Os resultados demonstraram que a ferramenta aumenta a granularidade dos conflitos (+253\%), mas reduz a quantidade de arquivos conflitantes em 10,8\%. A comparação revelou que a "Colagem Plana" (Estratégia 1) obteve a maior taxa de sucesso sintático (41,9\%), superando tanto a "Colagem Idiomática" (18,6\%) quanto a "Colagem Híbrida Protegida" (20,9\%). Isso evidencia que, em Haskell, a preservação da estrutura original é mais eficaz do que tentativas de proteção léxica ou formatação artificial.

\textbf{Palavras-chave}: Engenharia de Software. Merge de Código. Haskell. Haskell-SepMerge. Layout Rule.
\end{resumo}

% ABSTRACT
\begin{resumo}[Abstract]
\begin{otherlanguage*}{english}
Modern software development relies on version control systems to integrate parallel modifications. Traditional unstructured merge tools, such as \textit{diff3}, operate line-by-line and often report false conflicts in dense languages. Structured approaches address this using syntax trees but incur high costs. Alternatively, the CSDiff technique proposes using syntactic separators to segment code. This work proposes \textbf{Haskell-SepMerge}, an adaptation of CSDiff for Haskell, a functional language whose positional syntax (layout rule) challenges code reconstruction. Through an empirical study analyzing 388 real conflict scenarios, three reconstruction strategies were evaluated. Results showed that the tool increases conflict granularity (+253\%) but reduces the number of conflicting files by 10.8\%. The comparison revealed that "Flat Glue" (Strategy 1) achieved the highest syntactic success rate (41.9\%), outperforming both "Idiomatic Glue" (18.6\%) and "Protected Hybrid Glue" (20.9\%). This highlights that in Haskell, preserving the original structure is more effective than lexical protection or artificial formatting attempts.

\textbf{Keywords}: Software Engineering. Code Merge. Haskell. Haskell-SepMerge. Layout Rule.
\end{otherlanguage*}
\end{resumo}

% SUMÁRIO
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage

% ----------------------------------------------------------
% ELEMENTOS TEXTUAIS
% ----------------------------------------------------------
\textual

% CAPÍTULO 1
\chapter{Introdução}
\label{chap:introducao}

A colaboração em projetos de software exige que múltiplos desenvolvedores alterem a mesma base de código simultaneamente. Para gerenciar essas alterações e os desafios inerentes ao trabalho colaborativo, Sistemas de Controle de Versão (VCS) utilizam algoritmos de \textit{merge} (integração) para combinar as modificações \cite{edwards1997flexible, mens2002survey}.

A técnica predominante na indústria é o \textit{merge} textual não estruturado, exemplificado pelo algoritmo \textit{diff3} \cite{khanna2007formal}. Esta abordagem trata o código-fonte como uma sequência simples de linhas de texto. Embora eficiente, o \textit{diff3} possui limitações significativas: frequentemente reporta conflitos falsos (falsos positivos) quando as modificações ocorrem na mesma linha ou em linhas consecutivas. Além do impacto na produtividade, conflitos mal resolvidos ou não detectados podem introduzir defeitos na qualidade do software final \cite{brindescu2020empirical}.

Para mitigar esses problemas, \citeonline{clementino2021textual} propuseram o \textit{Custom Separators Diff} (CSDiff). Esta técnica propõe um pré-processamento do texto baseado em separadores sintáticos da linguagem, aumentando a granularidade da comparação.
\section{Problema de Pesquisa}
Enquanto o CSDiff foi validado para Java, sua eficácia em linguagens funcionais como **Haskell** permanece inexplorada. Haskell apresenta desafios únicos, sendo o principal a **Regra de Layout** (\textit{layout rule}). Em Haskell, o escopo de blocos é definido pela indentação. Ferramentas de \textit{merge} textual que alteram espaços em branco podem, inadvertidamente, alterar a semântica do programa ou impedir sua compilação.

Neste contexto, este trabalho investiga: \textit{Como adaptar a abordagem baseada em separadores para lidar com a sensibilidade posicional da linguagem Haskell?}

\section{Questões de Pesquisa}
\begin{itemize}
    \item \textbf{QP1:} O Haskell-SepMerge reduz a quantidade total de conflitos reportados?
    \item \textbf{QP2:} A ferramenta reduz a quantidade de arquivos que exigem intervenção manual?
    \item \textbf{QP3:} Qual estratégia de reconstrução produz mais código sintaticamente válido?
    \item \textbf{QP4:} A ferramenta introduz Falsos Negativos (divergências semânticas)?
\end{itemize}

\section{Objetivos}
O objetivo geral deste trabalho é desenvolver e avaliar a ferramenta **Haskell-SepMerge**, uma adaptação da técnica CSDiff para a linguagem Haskell. Os objetivos específicos são:
\begin{enumerate}
    \item Identificar o conjunto de separadores sintáticos relevantes para Haskell;
    \item Implementar e comparar diferentes estratégias de reconstrução de código (Plana, Idiomática e Híbrida) frente à Regra de Layout;
    \item Desenvolver uma infraestrutura de testes automatizada para validar a eficácia e segurança da ferramenta;
    \item Realizar um estudo empírico com repositórios reais para comparar o desempenho da ferramenta proposta frente ao algoritmo padrão \textit{diff3}.
\end{enumerate}

% CAPÍTULO 2
\chapter{Fundamentação Teórica}
\label{chap:fundamentacao}

\section{Integração de Software e suas Abordagens}
O processo de integração visa reconciliar mudanças paralelas. As abordagens podem ser classificadas em textuais e estruturadas.

A abordagem textual (\textit{diff3}) é agnóstica à linguagem, rápida e robusta, mas sofre com a falta de contexto semântico. Em contrapartida, pioneiros como \citeonline{westfechtel1991structure} e \citeonline{buffenbarger1993syntactic} propuseram o \textit{Merge Estruturado}, que opera sobre a estrutura sintática do programa. Trabalhos subsequentes, como o de \citeonline{apel2011semistructured}, evoluíram essa técnica utilizando Árvores Sintáticas Abstratas (AST).

Embora elimine conflitos de formatação, o merge estruturado enfrenta barreiras de adoção. Estudos comparativos indicam que essas ferramentas possuem alto custo de desenvolvimento de \textit{parsers} e complexidade computacional elevada, além da incapacidade de processar arquivos com erros de sintaxe momentâneos \cite{cavalcanti2019impact}.

A técnica CSDiff surge como um meio-termo: utiliza conhecimento sintático leve (apenas separadores) para segmentar o texto, mantendo o motor de comparação textual.

\section{Desafios Sintáticos do Haskell}
A escolha da linguagem Haskell justifica-se por suas características desafiadoras.

\subsection{A Regra de Layout}
Diferente de linguagens baseadas em chaves (como Java), Haskell utiliza indentação significativa \cite{marlow2010haskell}. O aninhamento de blocos é definido pelo alinhamento vertical. Isso cria um paradoxo: para resolver o conflito, a ferramenta precisa inserir quebras de linha, destruindo a estrutura de colunas original que precisa ser restaurada posteriormente.

\subsection{Densidade de Operadores}
Haskell favorece código conciso. Assinaturas de tipo e definições frequentemente compartilham a mesma linha, separadas por operadores como \texttt{::} ou \texttt{=>}. O \textit{merge} padrão enxerga qualquer mudança nessa linha densa como um conflito total.

% CAPÍTULO 3
\chapter{Metodologia}
\label{chap:metodologia}

\section{A Ferramenta Haskell-SepMerge}
A ferramenta foi desenvolvida em \textit{Bash} e \textit{AWK}. Foram implementados dois modos de operação (Simples e Completo) e três estratégias de reconstrução para avaliação.

\subsection{Estratégias de Reconstrução Avaliadas}
Para enfrentar o problema da *Layout Rule*, foram comparadas três versões do algoritmo de pós-processamento:

\begin{enumerate}
    \item \textbf{Estratégia 1 (Colagem Plana):} Prioriza a estabilidade. Reconstrói o arquivo tentando "colar" os tokens na mesma linha física anterior sempre que possível, preservando o espaçamento original dos ramos.
    \item \textbf{Estratégia 2 (Colagem Idiomática):} Tenta embelezar o código. Ao encontrar separadores verticais (como \texttt{=>}), insere uma quebra de linha e aplica uma indentação fixa de 4 espaços.
    \item \textbf{Estratégia 3 (Híbrida/Protegida):} Combina a lógica da Estratégia 1 com uma camada extra de proteção léxica. Tokens compostos (como \texttt{||} ou \texttt{==}) são substituídos por marcadores únicos (\texttt{HSS\_...}) antes do merge para evitar corrupção, sendo restaurados ao final.
\end{enumerate}

\begin{figure}[H]
  \centering
  \caption{Comparativo visual das Estratégias de Reconstrução propostas}
  \label{fig:estrategias-comparacao}
  
  % --- Linha Superior: O Input (Exemplo) ---
  \textbf{Cenário:} Reconstrução de uma assinatura de função complexa.\\
  \vspace{0.2cm}

  % --- Estratégia 1 ---
  \begin{minipage}[t]{0.48\textwidth}
      \textbf{Estratégia 1 (Colagem Plana)}
      \vspace{0.1cm}
      \begin{lstlisting}[basicstyle=\tiny\ttfamily, numbers=none, frame=single]
foo :: (Monad m) => a -> m b
foo = ...
      \end{lstlisting}
      \small{\textit{Resultado:} Mantém a linha única. Preserva a estrutura original dos ramos, mas pode ficar longo visualmente.}
  \end{minipage}
  \hfill
  % --- Estratégia 2 ---
  \begin{minipage}[t]{0.48\textwidth}
      \textbf{Estratégia 2 (Idiomática)}
      \vspace{0.1cm}
      \begin{lstlisting}[basicstyle=\tiny\ttfamily, numbers=none, frame=single]
foo :: (Monad m)
  => a
  -> m b
foo = ...
      \end{lstlisting}
      \small{\textit{Resultado:} Insere quebras em `=>` e `->` com 4 espaços. Visualmente agradável, mas arriscado para o compilador.}
  \end{minipage}

  \vspace{0.4cm}

  % --- Estratégia 3 (Mecanismo) ---
  \begin{minipage}[t]{0.98\textwidth}
      \textbf{Estratégia 3 (Mecanismo de Proteção Híbrida)}
      \vspace{0.1cm}
      \begin{lstlisting}[basicstyle=\tiny\ttfamily, numbers=none, frame=single]
-- Passo 1: Substituição (Pré-Merge)
foo HSS_DOUBLE_COLON (Monad m) HSS_FAT_ARROW a HSS_ARROW m b

-- Passo 2: Merge Textual (Diff3)
...

-- Passo 3: Restauração (Pós-Merge)
foo :: (Monad m) => a -> m b
      \end{lstlisting}
      \small{\textit{Mecanismo:} Os tokens são "blindados" para evitar que o algoritmo de merge os fragmente (ex: transformar `=>` em `= >`), garantindo integridade léxica antes da reconstrução plana.}
  \end{minipage}

  \legend{Fonte: Elaborado pelo autor.}
\end{figure}

\section{Infraestrutura e Processo de Análise}
Para validar os resultados, desenvolveu-se um script de automação em Python que opera da seguinte forma para cada cenário minerado:
\begin{enumerate}
    \item \textbf{Execução:} Roda o \textit{diff3} e as três variações do \textit{Haskell-SepMerge} em paralelo.
    \item \textbf{Métricas:} Contabiliza conflitos e arquivos resolvidos.
    \item \textbf{Validação (Parse Check):} Se resolvido, invoca \texttt{ghc -fno-code} para verificar a validade sintática.
    \item \textbf{Equivalência:} Compara o resultado automático com a resolução manual, ignorando espaços em branco.
\end{enumerate}

Foram minerados os repositórios \textit{ShellCheck}, \textit{Pandoc}, \textit{Cabal} e \textit{Stack}, totalizando 388 cenários de conflito.

% CAPÍTULO 4
\chapter{Resultados e Discussão}
\label{chap:resultados}

Esta seção apresenta os dados consolidados do experimento no modo Completo (\textit{--full}).

\section{Granularidade e Eficácia (QP1 e QP2)}
A Tabela \ref{tab:granularidade} apresenta o impacto da ferramenta na quantidade de conflitos.

\begin{table}[htb]
\caption{Comparativo de Conflitos e Arquivos Pendentes}
\label{tab:granularidade}
\centering
\begin{tabular}{lccc}
\hline
\textbf{Métrica} & \textbf{Diff3 (Padrão)} & \textbf{Haskell-SepMerge} & \textbf{Variação} \\ \hline
Total de Conflitos & 2.191 & $\approx$ 7.700 & \textbf{+253\%} \\
Arquivos com Conflitos & 387 & 345 & \textbf{-10,85\%} \\ \hline
\end{tabular}
\legend{Fonte: Elaborado pelo autor.}
\end{table}

Observa-se uma explosão na granularidade (+253\%), comum a todas as estratégias. No entanto, essa fragmentação permitiu resolver automaticamente 43 arquivos (redução de 10,85\% no esforço manual).

\section{Análise de Validade Sintática (QP3)}
A validação com o GHC revelou diferenças críticas. A Tabela \ref{tab:sintaxe} mostra o sucesso das estratégias nas 43 resoluções automáticas.

\begin{table}[htb]
\caption{Taxa de Sucesso Sintático por Estratégia de Reconstrução}
\label{tab:sintaxe}
\centering
\begin{tabular}{lcc}
\hline
\textbf{Estratégia} & \textbf{Arquivos Válidos (ParseOK)} & \textbf{Taxa de Sucesso} \\ \hline
Estratégia 1 (Colagem Plana) & \textbf{18} & \textbf{41,9\%} \\
Estratégia 3 (Híbrida/Protegida) & 9 & 20,9\% \\
Estratégia 2 (Colagem Idiomática) & 8 & 18,6\% \\ \hline
\end{tabular}
\legend{Fonte: Elaborado pelo autor.}
\end{table}

**A Estratégia 1 (mais simples) obteve o melhor desempenho (41,9\%)**, superando as abordagens mais complexas.
A Estratégia 2 falhou ao tentar impor indentação artificial (4 espaços) em contextos aninhados. Surpreendentemente, a Estratégia 3 (Híbrida) também teve baixo desempenho. Embora protegesse os tokens, a alteração textual causada pelos marcadores de proteção (\texttt{HSS\_...}) interferiu no algoritmo de alinhamento do \textit{diff3}, gerando integrações que, embora léxicamente seguras, quebravam o layout posicional.

\section{Divergências e Falsos Negativos (QP4)}
A análise de divergência reforça a superioridade da abordagem simples:
\begin{itemize}
    \item \textbf{Estratégia 1:} 17 divergências em relação ao manual.
    \item \textbf{Estratégia 3 (Híbrida):} 32 divergências.
\end{itemize}
A alta divergência na Estratégia Híbrida indica que a "proteção de tokens" introduz ruído excessivo, levando a ferramenta a produzir código que difere substancialmente da solução humana, aumentando o risco de falsos negativos.

% CAPÍTULO 5
\chapter{Conclusão}
\label{chap:conclusao}

Este trabalho avaliou o Haskell-SepMerge. Os resultados levam a conclusões importantes sobre o \textit{merge} em linguagens baseadas em indentação:

\begin{enumerate}
    \item **Potencial de Resolução:** A ferramenta reduz em \textbf{10,8\%} a quantidade de arquivos conflitantes.
    \item **Simplicidade vs. Complexidade:** A Estratégia 1 (Colagem Plana) provou-se superior à Estratégia 2 (Idiomática) e à Estratégia 3 (Híbrida). Em Haskell, preservar o espaçamento original (mesmo que "feio") é mais seguro do que tentar sintetizar indentação ou proteger tokens agressivamente. A proteção excessiva de tokens (Estratégia 3) provou-se contraproducente, gerando mais divergências do que benefícios.
\end{enumerate}

\section{Trabalhos Futuros}
Recomenda-se o uso de uma arquitetura de pipeline: utilizar a Estratégia 1 para resolver a lógica do conflito e, imediatamente após, invocar um formatador externo robusto (como \textit{ormolu}) para corrigir a estética, garantindo integridade semântica e visual.

% ----------------------------------------------------------
% ELEMENTOS PÓS-TEXTUAIS
% ----------------------------------------------------------
\postextual
\bibliography{referencias}

\end{document}